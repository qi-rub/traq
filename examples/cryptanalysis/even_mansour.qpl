ext uproc P_U(BitVec<20>, BitVec<20>);

ext proc P(BitVec<20>, BitVec<20>);

ext uproc E_U(BitVec<20>, BitVec<20>);

ext proc E(BitVec<20>, BitVec<20>);

uproc f_U(f_x : IN BitVec<20>, f_fx : OUT BitVec<20>, f_ex : AUX BitVec<20>, f_px : AUX BitVec<20>, f_ex_1 : AUX BitVec<20>, f_px_1 : AUX BitVec<20>, f_fx_1 : AUX BitVec<20>) {
  call E_U(f_x, f_ex_1);
  f_ex, f_ex_1 *= SWAP;
  call P_U(f_x, f_px_1);
  f_px, f_px_1 *= SWAP;
  f_ex, f_px, f_fx_1 *= Embed[(f_ex, f_px) => (f_ex ^ f_px)];
  f_fx, f_fx_1 *= SWAP;
}

proc f(f_x : BitVec<20>, f_fx : BitVec<20>) { locals : (f_ex : BitVec<20>, f_px : BitVec<20>) } {
  call E(f_x, f_ex);
  call P(f_x, f_px);
  f_fx := (f_ex ^ f_px);
}

uproc USimon() {
  // TODO compileUPrim SimonsFindXorPeriod
}

uproc BreakEM_U(BreakEM_k1 : OUT BitVec<20>, BreakEM_k2 : OUT BitVec<20>, BreakEM_ze : AUX BitVec<20>, BreakEM_e_0 : AUX BitVec<20>, BreakEM_p_k1 : AUX BitVec<20>, BreakEM_ze_1 : AUX BitVec<20>, BreakEM_k1_1 : AUX BitVec<20>, BreakEM_e_0_1 : AUX BitVec<20>, BreakEM_p_k1_1 : AUX BitVec<20>, BreakEM_k2_1 : AUX BitVec<20>) {
  BreakEM_ze_1 *= Embed[() => 0:BitVec<20>];
  BreakEM_ze, BreakEM_ze_1 *= SWAP;
  call USimon(BreakEM_k1_1);
  BreakEM_k1, BreakEM_k1_1 *= SWAP;
  call E_U(BreakEM_ze, BreakEM_e_0_1);
  BreakEM_e_0, BreakEM_e_0_1 *= SWAP;
  call P_U(BreakEM_k1, BreakEM_p_k1_1);
  BreakEM_p_k1, BreakEM_p_k1_1 *= SWAP;
  BreakEM_e_0, BreakEM_p_k1, BreakEM_k2_1 *= Embed[(BreakEM_e_0, BreakEM_p_k1) => (BreakEM_e_0 ^ BreakEM_p_k1)];
  BreakEM_k2, BreakEM_k2_1 *= SWAP;
}

uproc SimonOneRound_U(aux : BitVec<20>, aux_1 : BitVec<20>, aux_2 : BitVec<20>, aux_3 : BitVec<20>, aux_4 : BitVec<20>, aux_5 : BitVec<20>, aux_6 : BitVec<20>, aux_7 : BitVec<20>) {
  aux *= Distr[uniform : BitVec<20>];
  call f_U(aux, aux_1, aux_3, aux_4, aux_5, aux_6, aux_7);
  aux_1, aux_2 *= COPY;
  call-adj f_U(aux, aux_1, aux_3, aux_4, aux_5, aux_6, aux_7);
  aux *= Adj-Distr[uniform : BitVec<20>];
}

proc QSimon(BreakEM_k1 : BitVec<20>) { locals : (QSimon__u : Arr<31, BitVec<20>>) } {
  for (i in 0 .. < 31) {
    meas SimonOneRound_U(QSimon__u[#i]);
  }
  // simon's post-processing: solve linear system: (BreakEM_k1) . (QSimon__u) = 0
}

proc BreakEM(BreakEM_k1 : BitVec<20>, BreakEM_k2 : BitVec<20>) { locals : (BreakEM_ze : BitVec<20>, BreakEM_e_0 : BitVec<20>, BreakEM_p_k1 : BitVec<20>, aux : BitVec<20>, aux_1 : BitVec<20>, aux_2 : BitVec<20>, aux_3 : BitVec<20>, aux_4 : BitVec<20>, aux_5 : BitVec<20>, aux_6 : BitVec<20>, aux_7 : BitVec<20>, QSimon__u : Arr<31, BitVec<20>>) } {
  BreakEM_ze := 0:BitVec<20>;
  call QSimon(BreakEM_k1);
  call E(BreakEM_ze, BreakEM_e_0);
  call P(BreakEM_k1, BreakEM_p_k1);
  BreakEM_k2 := (BreakEM_e_0 ^ BreakEM_p_k1);
}


// qubits: 200
