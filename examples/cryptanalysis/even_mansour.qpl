ext uproc P_U(BitVec<20>, BitVec<20>);

ext proc P(BitVec<20>, BitVec<20>);

ext uproc E_U(BitVec<20>, BitVec<20>);

ext proc E(BitVec<20>, BitVec<20>);

uproc f_U(x : IN BitVec<20>, fx : OUT BitVec<20>, ex : AUX BitVec<20>, px : AUX BitVec<20>, ex_1 : AUX BitVec<20>, px_1 : AUX BitVec<20>, fx_1 : AUX BitVec<20>) {
  call E_U(x, ex_1);
  ex, ex_1 *= SWAP;
  call P_U(x, px_1);
  px, px_1 *= SWAP;
  ex, px, fx_1 *= Embed[(ex, px) => (ex ^ px)];
  fx, fx_1 *= SWAP;
}

proc f(x : BitVec<20>, fx : BitVec<20>) { locals : (ex : BitVec<20>, px : BitVec<20>) } {
  call E(x, ex);
  call P(x, px);
  fx := (ex ^ px);
}

uproc SimonOneRound_U(x_1 : OUT BitVec<20>, y : AUX BitVec<20>, yy : AUX BitVec<20>, aux : AUX BitVec<20>, aux_1 : AUX BitVec<20>, aux_2 : AUX BitVec<20>, aux_3 : AUX BitVec<20>, aux_4 : AUX BitVec<20>) {
  x_1 *= Distr[uniform : BitVec<20>];
  call f_U(x_1, y, aux, aux_1, aux_2, aux_3, aux_4);
  y, yy *= COPY;
  call-adj f_U(x_1, y, aux, aux_1, aux_2, aux_3, aux_4);
  x_1 *= Adj-Distr[uniform : BitVec<20>];
}

uproc USimon(k1_1 : OUT BitVec<20>, USimon_aux : AUX Arr<31, BitVec<20>>, USimon_aux_1 : AUX Arr<31, BitVec<20>>, USimon_aux_2 : AUX Arr<31, BitVec<20>>, USimon_aux_3 : AUX Arr<31, BitVec<20>>, USimon_aux_4 : AUX Arr<31, BitVec<20>>, USimon_aux_5 : AUX Arr<31, BitVec<20>>, USimon_aux_6 : AUX Arr<31, BitVec<20>>, USimon_aux_7 : AUX Arr<31, BitVec<20>>) {
  for (#i in 0 .. < 31) {
    call SimonOneRound_U(USimon_aux[#i], USimon_aux_1[#i], USimon_aux_2[#i], USimon_aux_3[#i], USimon_aux_4[#i], USimon_aux_5[#i], USimon_aux_6[#i], USimon_aux_7[#i]);
  }
  // simon's post-processing: unitarily solve linear system: (k1_1) . (USimon_aux) = 0
}

uproc BreakEM_U(k1 : OUT BitVec<20>, k2 : OUT BitVec<20>, ze : AUX BitVec<20>, e_0 : AUX BitVec<20>, p_k1 : AUX BitVec<20>, ze_1 : AUX BitVec<20>, k1_1 : AUX BitVec<20>, x_1 : AUX BitVec<20>, y : AUX BitVec<20>, yy : AUX BitVec<20>, aux : AUX BitVec<20>, aux_1 : AUX BitVec<20>, aux_2 : AUX BitVec<20>, aux_3 : AUX BitVec<20>, aux_4 : AUX BitVec<20>, USimon_aux : AUX Arr<31, BitVec<20>>, USimon_aux_1 : AUX Arr<31, BitVec<20>>, USimon_aux_2 : AUX Arr<31, BitVec<20>>, USimon_aux_3 : AUX Arr<31, BitVec<20>>, USimon_aux_4 : AUX Arr<31, BitVec<20>>, USimon_aux_5 : AUX Arr<31, BitVec<20>>, USimon_aux_6 : AUX Arr<31, BitVec<20>>, USimon_aux_7 : AUX Arr<31, BitVec<20>>, aux_prim : AUX Arr<31, BitVec<20>>, aux_prim_1 : AUX Arr<31, BitVec<20>>, aux_prim_2 : AUX Arr<31, BitVec<20>>, aux_prim_3 : AUX Arr<31, BitVec<20>>, aux_prim_4 : AUX Arr<31, BitVec<20>>, aux_prim_5 : AUX Arr<31, BitVec<20>>, aux_prim_6 : AUX Arr<31, BitVec<20>>, aux_prim_7 : AUX Arr<31, BitVec<20>>, e_0_1 : AUX BitVec<20>, p_k1_1 : AUX BitVec<20>, k2_1 : AUX BitVec<20>) {
  ze_1 *= Embed[() => 0:BitVec<20>];
  ze, ze_1 *= SWAP;
  call USimon(k1_1, aux_prim, aux_prim_1, aux_prim_2, aux_prim_3, aux_prim_4, aux_prim_5, aux_prim_6, aux_prim_7);
  k1, k1_1 *= SWAP;
  call E_U(ze, e_0_1);
  e_0, e_0_1 *= SWAP;
  call P_U(k1, p_k1_1);
  p_k1, p_k1_1 *= SWAP;
  e_0, p_k1, k2_1 *= Embed[(e_0, p_k1) => (e_0 ^ p_k1)];
  k2, k2_1 *= SWAP;
}

uproc SimonOneRound_U_1(x_2 : OUT BitVec<20>, y_1 : AUX BitVec<20>, yy_1 : AUX BitVec<20>, aux_5 : AUX BitVec<20>, aux_6 : AUX BitVec<20>, aux_7 : AUX BitVec<20>, aux_8 : AUX BitVec<20>, aux_9 : AUX BitVec<20>) {
  x_2 *= Distr[uniform : BitVec<20>];
  call f_U(x_2, y_1, aux_5, aux_6, aux_7, aux_8, aux_9);
  y_1, yy_1 *= COPY;
  call-adj f_U(x_2, y_1, aux_5, aux_6, aux_7, aux_8, aux_9);
  x_2 *= Adj-Distr[uniform : BitVec<20>];
}

proc QSimon(k1 : BitVec<20>) { locals : (QSimon__u : Arr<31, BitVec<20>>) } {
  for (#i_1 in 0 .. < 31) {
    meas SimonOneRound_U_1(QSimon__u[#i_1]);
  }
  // simon's post-processing: solve linear system: (k1) . (QSimon__u) = 0
}

proc BreakEM(k1 : BitVec<20>, k2 : BitVec<20>) { locals : (ze : BitVec<20>, e_0 : BitVec<20>, p_k1 : BitVec<20>, x_2 : BitVec<20>, y_1 : BitVec<20>, yy_1 : BitVec<20>, aux_5 : BitVec<20>, aux_6 : BitVec<20>, aux_7 : BitVec<20>, aux_8 : BitVec<20>, aux_9 : BitVec<20>, QSimon__u : Arr<31, BitVec<20>>) } {
  ze := 0:BitVec<20>;
  call QSimon(k1);
  call E(ze, e_0);
  call P(k1, p_k1);
  k2 := (e_0 ^ p_k1);
}


// qubits: 10280
