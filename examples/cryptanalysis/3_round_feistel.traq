// Taken from paper: Breaking Symmetric Cryptosystems Using Quantum Period Finding
// https://link.springer.com/chapter/10.1007/978-3-662-53008-5_8

ext fn R1(BitVec<n>) -> BitVec<n> end
ext fn R2(BitVec<n>) -> BitVec<n> end
ext fn R3(BitVec<n>) -> BitVec<n> end

// Figure 3
fn E(xL: BitVec<n>, xR: BitVec<n>) -> (BitVec<n>, BitVec<n>) do
    u0 <- xL;
    v0 <- xR;

    // first round
    R1u0 <- R1(u0);
    u1 <- v0 ^ R1u0;
    v1 <- u0;

    // second round
    R2u0 <- R2(u1);
    u2 <- v1 ^ R2u0;
    v2 <- u1;

    // third round
    R3u2 <- R3(u2);
    u3 <- v2 ^ R3u2;
    v3 <- u2;

    return u3, v3
end 

ext fn alpha(Bool) -> BitVec<n> end

fn f(b : Bool, x : BitVec<n>) -> (Bool, BitVec<n>) do
    alpha_b <- alpha(b);
    yL, yR <- E(alpha_b, x);

    res <- yR ^ alpha_b;

    zero <- const 0 : Bool;

    return zero, res
end

fn AttackThreeRoundFeistel() -> BitVec<n> do
    zero, s <- @findXorPeriod<n_plus_1, 0.01>[f(_, _)];
    
    return s

    //// Verify the computed period:
    // zero <- const 0 : Bool;
    // alpha_0 <- alpha(zero);

    // one <- const 1 : Bool;
    // alpha_1 <- alpha(one);

    // x <- uniform : BitVec<n>;
    // yL, yR <- E(alpha_0, x);

    // yL', yR' <- E(alpha_1, x ^ s);

    // actual <- (yR ^ yR')
    // expected <- (alpha_0 ^ alpha_1);
    // success <- actual == expected; 

    // return success;
end

