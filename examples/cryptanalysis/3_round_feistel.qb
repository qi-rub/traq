// Taken from paper: Breaking Symmetric Cryptosystems Using Quantum Period Finding
// https://link.springer.com/chapter/10.1007/978-3-662-53008-5_8

declare R1(Fin<N>) -> Fin<N> end
declare R2(Fin<N>) -> Fin<N> end
declare R3(Fin<N>) -> Fin<N> end

// Figure 3
def E(xL: Fin<N>, xR: Fin<N>) -> (Fin<N>, Fin<N>) do
    u0 <- xL;
    v0 <- xR;

    // first round
    R1u0 <- R1(u0);
    u1 <- v0 ^ R1u0;
    v1 <- u0;

    // second round
    R2u0 <- R2(u1);
    u2 <- v1 ^ R2u0;
    v2 <- u1;

    // third round
    R3u2 <- R3(u2);
    u3 <- v2 ^ R3u2;
    v3 <- u2;

    return u3, v3
end 

declare alpha(Bool) -> Fin<N> end

def f(b : Bool, x : Fin<N>) -> Fin<N> do
    alpha_b <- alpha(b);
    yL, yR <- E(alpha_b, x);

    res <- yR ^ alpha_b;

    return res
end

def AttackThreeRoundFeistel() -> Bool do
    b, s <- @findXorPeriod[f, 0.01]();
    
    return b, s

    //// Verify the computed period:
    // zero <- const 0 : Bool;
    // alpha_0 <- alpha(zero);

    // one <- const 1 : Bool;
    // alpha_1 <- alpha(one);

    // x <- uniform : Fin<N>;
    // yL, yR <- E(alpha_0, x);

    // yL', yR' <- E(alpha_1, x ^ s);

    // actual <- (yR ^ yR')
    // expected <- (alpha_0 ^ alpha_1);
    // success <- actual == expected; 

    // return success;
end

