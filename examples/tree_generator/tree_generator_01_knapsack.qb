// Algorithm as described in [A quantum algorithm for solving 0-1 Knapsack problems](https://arxiv.org/abs/2310.06623)

// 0-1 Knapsack instance over N variables:
declare Capacity () -> Fin<W> end
declare Profit (Fin<N>) -> Fin<P> end
declare Weight (Fin<N>) -> Fin<W> end

// add the weight of the i-th item to the total
def AddWeight(xs: Arr<N, Bool>, cur_wt: Fin<W>, i: Fin<N>) -> (Arr<N, Bool>, Fin<W>) do
    xi <- xs[i];
    wi <- Weight(i);

    zero <- const 0 : Fin<W>;
    wi_pick <- xi ? wi : zero;

    new_wt <- cur_wt + wi_pick;
    xs' <- xs;
    return xs', new_wt
end

// Total weight of a given assignment xs
def TotalWeight(xs: Arr<N, Bool>) -> Fin<W> do
    zero <- const 0 : Fin<W>;
    xs', wt <- loop (xs, zero) AddWeight;
    return wt
end

// add the profit of the i-th item to the total
def AddProfit(xs: Arr<N, Bool>, cur_pr: Fin<P>, i: Fin<N>) -> (Arr<N, Bool>, Fin<P>) do
    xi <- xs[i];
    pi <- Profit(i);

    zero <- const 0 : Fin<P>;
    pi_pick <- xi ? pi : zero;

    new_pr <- cur_pr + pi_pick;
    xs' <- xs;
    return xs', new_pr
end

// Total profit of a given assignment xs
def TotalProfit(xs: Arr<N, Bool>) -> Fin<P> do
    zero <- const 0 : Fin<P>;
    xs', pr <- loop (xs, zero) AddProfit;
    return pr
end

// For the i-th element, flip it with some probability $p$, and pick it only if it can be added within capacity. 
def TreeGenLoopBody(xs: Arr<N, Bool>, wt: Fin<W>, pr: Fin<P>, i: Fin<N>) -> (Arr<N, Bool>, Fin<W>, Fin<P>) do
    xi <- xs[i]; // old value
    y <-$ bernoulli[0.2]; // should change? (w.p. 0.2)
    try_pick <- xi ^ y; // should pick?

    // check the capacity
    wi <- Weight(i);
    wt_picked <- wt + wi;

    c <- Capacity();
    can_fit <- wt_picked <= c;

    // pick if both above conditions work
    should_pick <- try_pick && can_fit;

    // update
    xs' <- update xs[i] = should_pick;
    new_wt <- should_pick ? wt_picked : wt;

    pi <- Profit(i);
    pr_picked <- pr + pi;
    new_pr <- should_pick ? pr_picked : pr;

    return xs', new_wt, new_pr
end

// Run the "tree-generator" algorithm to return a biased sample of an assignment, that fits the capacity.
// The flag is if the new assignment has a higher profit.
def TreeGen(xs: Arr<N, Bool>, pr: Fin<P>) -> (Bool, Arr<N, Bool>) do
    zero_wt <- const 0 : Fin<W>;
    zero_pr <- const 0 : Fin<P>;
    xs', wt', pr' <- loop (xs, zero_wt, zero_pr) TreeGenLoopBody;
    ok <- pr' > pr; // profit increased
    return ok, xs'
end

// Run one iteration of the tree generator to obtain a good sample
def KnapsackLoopBody(xs: Arr<N, Bool>, i: Fin<K>) -> Arr<N, Bool> do
    pr <- TotalProfit(xs);
    ok, xs' <- @amplify[TreeGen, 0.01](xs, pr);
    xs_next <- ok ? xs' : xs;
    return xs_next
end

// Start with an empty assignment and perform $K$ iterations of local search to maximize profit. 
def Knapsack() -> Arr<N, Bool> do
    xs <- default : Arr<N, Bool>;
    xs' <- loop (xs) KnapsackLoopBody;
    return xs'
end
